#!/usr/bin/env python3

"""
# 
#                     ___                                                        
#   _ __ _   _ _ __  / _ \                                                       
#  | '__| | | | '_ \| | | |                                                      
#  | |  | |_| | | | | |_| |                                                      
#  |_|  _\__,_|_| |_|\__\_\_____ __  __ _   _                                    
#  | |_| |__   ___   / _ \| ____|  \/  | | | |  _ __ _   _ _ __  _ __   ___ _ __ 
#  | __| '_ \ / _ \ | | | |  _| | |\/| | | | | | '__| | | | '_ \| '_ \ / _ \ '__|
#  | |_| | | |  __/ | |_| | |___| |  | | |_| | | |  | |_| | | | | | | |  __/ |   
#   \__|_| |_|\___|  \__\_\_____|_|  |_|\___/  |_|   \__,_|_| |_|_| |_|\___|_|   
#                                                                                
# 
#  
#  Add argument with +
#  Remove argument with -
#  Avoid using the pre-configured arguments by prefixing nothing
#
#
#  ./runq [config_file] [(+|-)argument(=value) ...]
"""

from __future__ import print_function


import os
import sys

import shlex
import functools


CONFIG: dict[str, any] = {
    'smp': '1',
}


# ──────────────────────────────────────────────────────────────────────────────

def find(fn):
    dn = os.path.dirname(fn)
    if not dn:
        dn = '.'

    if not os.path.isdir(dn):
        return None

    for root, _, fs in os.walk(os.path.abspath(dn), followlinks = True):
        for f in fs:
            if f.startswith(fn):
                return os.path.join(root, f)

    return None


def norm(fn):
    fn  = os.path.expandvars(fn)

    if fn.find(os.sep) < 0:
        return fn

    old = fn.split(os.sep)
    ret = []

    # explicit root
    if fn.startswith(os.sep):
        ret.append('')

    for i in old:
        if i == '.':
            continue
        elif i == '..':
            if ret:
                ret.pop()
        elif i:
            ret.append(i)

    return os.sep.join(ret)


def test(cs, opts):
    last = cs[-1] if cs else True
    cond = False

    for op in opts:
        if op == 'OR':
            continue

        cond = cond or op in os.environ

    cs.append(cond and last)

def parse_config(file):

    print(f'file={file}')
    args = []
    curr = []
    cond = []

    with open(file) as fd:
        for cs in fd:
            if cs.startswith(('#', '//')):
                continue

            if cs.startswith('IF '):
                test(cond, cs.split()[1:])
                continue

            if cs.startswith('ENDIF'):
                if cond:
                    cond.pop()
                continue

            if cond and not cond[-1]:
                continue

            sp = shlex.split(cs)
            if not sp:
                continue

            if cs.startswith((' ', '\t')):
                curr.append('='.join(list(map(lambda x: norm(x), sp[:2]))))

            else:
                if curr:
                    args.append(','.join(curr))
                    curr = []

                args.append('-{}'.format(sp[0]))

        if curr:
            args.append(','.join(curr))

        return args


def main(*opts):
    """
    Get options from the command line, parse them and run the 
    QEMU binaires using the computed argmuments
    """

    real: list[str] = []

    for op in opts:

        if not op.isascii(): continue

        if not op.startswith('+'):
            real.append(op)
            continue

        if '=' not in op:
            CONFIG[op.lstrip("+")] = "1"
            continue
        
        if '=' in op :
            #! if this fail here, this mean that there was an '=' in the value (weird)
            key, value = op.lstrip("+").split('=')
            CONFIG[key] = value 



    # Checking if we need to use the base config file
    real = ['-'] if (len(real) == 0) else real
    use_default_config:bool = real[0].startswith('-')

    # Refactor the too greedy search function
    config_file:str = find('emu' if use_default_config else real[0])  
    qemu:str = find('qemu')


    if not config_file or not qemu:
        exit("ERROR: Could not find 'qemu' or a config file")

    # always provided
    CONFIG['root'] = os.path.dirname(os.path.abspath(config_file))

    args = [qemu]
    c_args = parse_config(config_file)

    args.extend(c_args)

    # especially for -S -s or -d ...
    args.extend(real[0 if use_default_config else 1:])

    for k, v in CONFIG.items():
        os.environ[k] = v

    if 'dbg' in os.environ:
        args = ['gdb', '--args'] + args

    if 'dry' in os.environ:
        print(' '.join(args))
    else:
        os.execvp(args[0], args)


if __name__ == '__main__':
    main(*sys.argv[1:])
